# 設計文件

## Vimkeys 遊戲
這款遊戲結合了 VIM 按鍵綁定和類似貪食蛇的遊戲玩法。

### 基本遊戲玩法：
玩家使用 VIM 按鍵綁定在網格狀地圖中移動。
遊戲在視圖中的固定（或隨機）位置散布收集物。
如果使用計時器，遊戲在計時器歸零時結束。
否則，遊戲在拾取最後一個收集物時結束。

### 這款遊戲的獨特之處和樂趣：
遊戲包含豐富的移動動作和遊戲選項。
玩家可以根據自己的喜好配置所有按鍵綁定和遊戲玩法。
目標是讓玩家學習什麼樣的按鍵綁定和遊戲玩法最適合自己。

### 這款遊戲的主要組成部分：

- 100: 動作-移動
- 200: 配置-遊戲玩法（拾取模式）
  - 關鍵詞：拾取器、填充器、計時器、剩餘計數器、勝負條件
- 300: 配置-按鍵綁定
  - 關鍵詞：按鍵綁定
- 400: 視覺-背景
  - 關鍵詞：地圖、網格、視圖
- 500: 視覺-前景
  - 關鍵詞：物品、玩家、收集物、符文、障礙物、傳送門
  - 快速定義：前景指的是在單元格中渲染的物品
  - 待定義：可以在同一單元格中渲染的物品類型和最大數量
- 600: 視覺-HUD
  - 關鍵詞：計分板、配置彈窗
- 700: 配置-遊戲玩法（填充模式）

### 關鍵詞和定義：
- **物品 (item)** => 在單元格內渲染的任何東西都是物品（視覺前景）
  - 例如：收集物、具有特殊功能的符文
    - 超連結、傳送門、障礙物（玩家無法踏上障礙物）
- **單元格 (cell)** => 視覺背景的最小單位
  - 玩家可以踏上單元格，除非它包含障礙物
  - 一個單元格可以包含一個到多個 ASCII 可打印字符作為物品
  - 注意：如果單元格包含障礙物，則不能包含任何其他物品
- **收集物或可掉落物 (collectable or droppable)** => 玩家踏上後會被清除的物品
  - 玩家每次清除收集物都會獲得分數
- **拾取器或拾取模式 (picker or pickup mode)** => 玩家在視圖內移動並拾取所有收集物
  - 清除所有收集物後贏得遊戲
- **填充器或填充模式 (filler or fill-up mode)** => 玩家在視圖內移動；玩家移動會在視圖上留下軌跡
  - 當移動軌跡與關卡的給定模式匹配時贏得遊戲
  - 每個關卡都有一個閾值；一旦「匹配比率」超過閾值，玩家就贏得遊戲
- **視圖 (view)** => 玩家可見和可操作的整個區域
  - 一個視圖可以同時包含一個或多個網格
  - 兩個不同網格之間應該有邊距
- **網格 (grid)** => 網格由 N×M 個單元格組成

- **超連結 (hyperlink)** => 連結到當前視圖的一個單元格
  - 或連結到另一個視圖


## 設計原則

- **這應該是快節奏的遊戲玩法**
  - 即，每次按鍵都應該在一定程度上影響遊戲進度
  - 因此，遊戲玩法應盡可能消除非移動動作
  - 例如，不要讓玩家按空格鍵來拾取物品
    - 不要讓玩家按某個鍵來進入傳送門
- **有目的地隨機化**
  - 隨機生成的關卡和固定關卡應該有不同的設計
  - 某些功能最適合隨機生成的關卡，而某些則不適合
  - 即使可以最大化遊戲玩法的「可配置」部分
  - 如果這些配置選項一開始就沒有意義，遊戲仍應明智地處理它們
- **明顯的捷徑不會改善遊戲體驗**
  - 不要向玩家引入普遍全能的功能
  - 濫用相同的明顯策略來擊敗每個關卡會顯著降低遊戲體驗
  - 例如，「返回」捷徑允許玩家隨時隨地導航回上一個視圖

## 遊戲流程

### 遊戲模式選擇器

在遊戲開始之前，玩家選擇一個遊戲模式。這是一個高階切換，會替換整個遊戲配置：

| 模式   | 描述                                      | 參考      |
| ------ | ----------------------------------------- | --------- |
| 拾取器 | 默認模式。在視圖上拾取收集物。              | items#200 |
| 填充器 | 匹配顏色來清除收集物。                      | items#700 |

### 狀態機

```
┌─────────────┐     \     ┌─────────────┐
│  遊戲外狀態  │◀─────────▶│  遊戲中狀態  │
└─────────────┘           └─────────────┘
```

只存在兩種遊戲狀態：

- **遊戲中 (In-Game)**
  - 活動遊戲狀態
  - 按 `\` 停止遊戲並返回遊戲外狀態
  - HUD 顯示：
    - 當前分數
    - 計時器或剩餘收集物（取決於模式）
    - 連擊狀態（如果啟用）

- **遊戲外 (Out-of-Game)**
  - 按 `\` 開始遊戲
  - HUD 顯示：
    - 遊戲模式選擇器（拾取器 / 填充器）
    - 上一場遊戲分數
    - 最高分數（全部時間）
    - 配置彈窗（訪問按鍵綁定和遊戲設置）
    - 關卡切換

### 保留按鍵綁定

這些按鍵綁定始終啟用且無法重新映射：

| 按鍵          | 動作                                        |
| ------------- | ------------------------------------------- |
| `\`           | 開始遊戲（遊戲外）/ 停止遊戲（遊戲中）       |
| `=`           | 切換到下一關卡                               |
| `<backspace>` | 切換到上一關卡                               |
| `]`           | 隨機化關卡（僅限動態生成的關卡）             |
| `Escape`      | 打開/關閉設置菜單                            |
| `Enter`       | 確認菜單中的選擇                             |

### 關卡切換

玩家可以使用 `=` 和 `<backspace>` 在關卡之間循環：

| 關卡                   | 描述                                                                             |
| ---------------------- | -------------------------------------------------------------------------------- |
| 演示關卡               | 用於自由移動練習的特殊無盡關卡。無法開始。詳見下文。                               |
| 預定義關卡 1           | 具有預設佈局的固定關卡。                                                          |
| 預定義關卡 2           | 具有預設佈局的固定關卡。                                                          |
| 預定義關卡 3           | 具有預設佈局的固定關卡。                                                          |
| 動態生成關卡           | 隨機生成的關卡。按 `]` 重新生成。                                                |

#### 演示關卡詳情

演示關卡是一個特殊的沙盒模式：
- **無法開始**（`\` 鍵無效；關卡始終處於可玩狀態，無需進入正式的遊戲中模式）
- **無盡遊戲玩法**：一旦清除所有收集物，它們會自動重生
- **支持的功能**：拾取收集物、障礙物、傳送門、所有移動動作
- **不支持的功能**：連擊系統、分數計算、勝負條件

### 轉換

| 從          | 到          | 觸發器                          |
| ----------- | ----------- | ------------------------------- |
| 遊戲外狀態  | 遊戲中狀態  | 玩家按下 `\`                    |
| 遊戲中狀態  | 遊戲外狀態  | 玩家按下 `\` 或滿足勝利條件     |

### 勝負條件摘要

| 模式   | 子模式                            | 勝利條件                         | 失敗條件 | 分數計算                         |
| ------ | --------------------------------- | -------------------------------- | -------- | -------------------------------- |
| 拾取器 | 固定收集物數量（items#200）       | 清除所有收集物                   | 無       | 基於速度（時間越少越好）          |
| 拾取器 | 固定時間（items#200）             | 計時器結束                       | 無       | 基於分數（拾取越多越好）          |
| 填充器 | -（items#700）                    | 清除所有顏色匹配的收集物         | 無       | 基於速度（時間越少越好）          |

**注意：**
- 此遊戲目前沒有失敗條件；所有模式在滿足勝利條件時結束
- 帶有 `remain_counter` 的拾取器模式使用基於速度的計分
- 帶有 `timer` 的拾取器模式使用基於分數的計分
- 填充器模式始終基於速度（最快完成時間獲勝）
- 有關詳細計分公式，請參見 items#236

## 100: 動作-移動

基本移動是 `hjkl`，它一次在網格內移動玩家一個單元格。
`hjkl` 借用了 VIM 的傳統方向：左、下、上、右。

### 105: 玩家初始化

遊戲開始時，必須使用以下屬性初始化玩家：

#### 起始位置
- **拾取器模式（隨機關卡）：** 玩家在隨機未佔用的單元格生成，或者如果未佔用則在網格中心生成
- **拾取器模式（固定關卡）：** 玩家在關卡數據中指定的預定義位置生成
- **填充器模式：** 玩家在關卡數據中指定的預定義位置生成

#### 初始狀態
| 屬性         | 初始值 | 注意事項                         |
| ------------ | ------ | -------------------------------- |
| 身體長度     | 1      | 佔用單個單元格                   |
| 活動部分     | 頭部   | 用於身體長度 > 1 的場景          |
| 面向方向     | 右     | 影響某些移動計算                 |
| 分數         | 0      | -                                |
| 連擊連勝     | 0      | 如果啟用連擊系統                 |
| 當前顏色     | 無     | 僅限填充器模式                   |

#### 生成約束
- 生成單元格不得包含障礙物
- 生成單元格不得包含傳送門（以避免立即傳送）
- 對於隨機關卡，確保至少有一個收集物可以從生成位置到達

### 110: 碰撞

這個遊戲中「碰撞」有幾種含義。
基本概念是玩家從單元格 A 移動到單元格 B；如果單元格 B 包含另一個物品，則玩家與該物品「碰撞」。
讓我們擴展這個陳述：
- **111**: 如果 A 和 B 之間的距離大於 1，這表示移動一次穿越多個單元格
  - 這表示在過程中可能發生多次碰撞
- **112**: 移動動作可能是可傳送的
  - 如果移動動作是可傳送的，則僅考慮目標單元格可碰撞
  - 即，忽略單元格 A 和 B 之間的所有碰撞
- **113**: 可以將物品設置為不可碰撞，這意味著即使發生碰撞也不會觸發碰撞事件
  - 收集物和障礙物是可碰撞的
  - 符文是不可碰撞的
  - 如果多個可碰撞物品佔據同一單元格，則會觸發該單元格的所有碰撞事件
- **114**: 碰撞基本上是引擎定義的事件
  - 當玩家與收集物碰撞時：玩家拾取收集物
    - 從屏幕上移除收集物，分數 + 1
  - 當玩家與障礙物碰撞時：將玩家推回與來的方向相反的方向
    - 即，玩家無法踏上障礙物
- **115**: 如果單元格 B 超出當前網格的邊界，它也應該觸發邊界碰撞事件
  - 默認行為是將玩家移動到網格的邊界（可行的單元格）

#### 邊緣案例

玩家從單元格 A 移動到單元格 C；單元格 B 位於 A 和 C 之間。
單元格 B 包含障礙物。
移動類型是傳送。
預期：玩家應該傳送到單元格 C，而不會被單元格 B 中的障礙物阻擋。

### 120: 基本移動

屬性：
- collidible: true

#### 邊緣案例

定義玩家碰到網格邊界時會發生什麼：
- 停留在上一個單元格而不移動
- 傳送到移動方向上最近的網格
  - 如果玩家向左移動並且左側有可用的網格
  - 將玩家移動到左側網格的右邊界
  - 例如，new-row-index == old-row-index; new-col-index == new-cols.at(-1)

### 130: 網格移動

一個視圖可以包含多個網格。
網格移動意味著玩家從網格 A 傳送到網格 B。

屬性：
- collidible: false
- 默認按鍵綁定：`<c-h> <c-j> <c-k> <c-l>`
  - `<c-h>` 將玩家傳送到左方向的網格
  - 如果左邊沒有網格，玩家停留在當前單元格而不移動
  - 如果左邊有網格
    - 玩家傳送到左側網格的單元格
    - 該單元格具有與傳送前相同的行列索引
    - 例如，從 cur-grid(3,4) 到 dest-grid(3,4)

### 140: 符文

符文是一種不可碰撞但可以與某些移動動作交互的物品。

屬性：
- collidable: false

#### 物品屬性參考

所有前景物品屬性在第 500 節（視覺-前景）中定義。參見：
- items#520 符文屬性
- items#540 障礙物屬性
- items#532 傳送門屬性
- 收集物屬性在 items#200（配置-遊戲玩法）中內聯定義

#### 141: 角括號

直接在單元格中渲染角括號 '<' 和 '>'。
這有點類似於經典 VIM 的「單詞邊界」功能，只是單詞邊界現在可視化並直接作為字符渲染在單元格中。
（另一方面，VIM 單詞邊界是零寬度斷言。）
玩家可以使用 `qwer` 傳送到視圖上現有的角括號：
- `q` 向後方向傳送到最近的左角括號 '<'（從 n,n 到 0,0）
- `w` 向後方向傳送到最近的右角括號 '>'（從 n,n 到 0,0）
- `e` 向前方向傳送到最近的左角括號 '<'（從 0,0 到 n,n）
- `r` 向前方向傳送到最近的右角括號 '>'（從 0,0 到 n,n）

#### 142: 字母

在單元格中渲染字母。
此功能類似於 VIM 編輯器中正常字符的工作方式。
基本上，玩家可以使用查找命令後跟一個字符跳轉到單元格。
唯一的區別是在 VIM 中，字母通常在文本文件中到處渲染，並且單詞邊界的概念建立在其之上。
在遊戲中，字母是稀疏渲染的，它們與單詞邊界無關，因為單詞邊界是由角括號明確表示的。

玩家可以使用 `f` 向前方向搜索字母（使用 `d` 向後搜索），按下代表字母的鍵，然後直接傳送到該單元格（字母的第一次出現）。
注意，`f` 的工作方式與 VIM 中的實現不同，這裡的功能跨多行搜索，而 VIM 只在同一行中搜索。

### 150: 宏

宏是一組預定義的動作，允許玩家在一次按鍵中執行多個動作。
它大多等同於 VIM 中宏的工作方式，除了：
- 玩家無法自己錄製宏
- 宏由單次按鍵觸發，而不是 `@` 後跟另一次按鍵
- 有兩種不同的方式來定義宏：
  1. 在按鍵綁定配置菜單中定義它（有限制）
  2. 通過在遊戲中拾取增益道具

#### 限制

宏非常強大，它們應該有一些「限制」以確保它們不會破壞遊戲玩法（即，使遊戲變得極其容易）。

對於在按鍵綁定配置菜單中定義的宏：
- 配置彈窗應允許玩家在單個宏中定義最多 6 個基本移動
- 此限制確保宏保持平衡，不會使遊戲變得微不足道

一些可能的宏：
- 向左移動 5 次（即，hhhhh）
- 向左移動 3 次，然後向下移動 3 次（即，hhhjjj）

#### 設計背景

第一個版本是一個非常簡單的可配置基本移動，具有可配置的乘數。
然而，經過幾次遊戲後，這個設計感覺很無聊。
然後，我想到了以 L 形移動的想法，類似於國際象棋中騎士的移動方式。
作為替代方案，將宏製作成可收集的增益道具，這使得宏只能在玩家在遊戲中拾取增益道具後才能執行。
仍然需要更多評估來檢查這是否真的好玩。

### 160: 模式移動

模式移動類似於 VIM 中 `#*(){}[]%` 的工作方式：
- 玩家可以使用 `#*` 傳送到游標下的下一個符號
- 玩家可以使用 `()` 傳送到下一個句子
- 玩家可以使用 `{}` 傳送到下一個段落
- 玩家可以使用 `[]` 傳送到下一個部分
- 玩家可以使用 `%` 傳送到下一個配對結構

然而，我認為這種移動過度複雜化了遊戲玩法。
我們應該將其保留在待辦事項中而不實際實現它。

#### 更多模式

通過引入 LSP 和 AST 可以定義更多模式。
同樣，引入這些功能會過度複雜化遊戲玩法。

### 170: 重複器

#### 設計筆記

這個功能受到 VIM `;,` 重複最後一個內聯命令和 `np` 重複最後一個查找命令的啟發
在這裡，我通過引入兩個更多的概念來調整設計：
1. 使重複器適應除基本移動之外的任何類型的移動動作（在 VIM 中，重複器只適用於內聯查找和搜索命令）
2. VIM 版本只註冊了兩次按鍵，重複器重複「方向」和移動
  - 我建議重複器應該只重複移動，讓按鍵本身決定方向
  - 這個改變會使按鍵的方向確定性，這似乎減少了玩家的認知負擔
目前有兩個提案可用

可用的非基本移動：
- 網格移動 items#130
- 符文：角括號 items#141
- 符文：字母 items#142

#### 171: 提案 1（已放棄）

此功能是一組三次按鍵：
例如，`m,<.`
注意：在 QWERTY 鍵盤上，`,` 和 `<` 共享同一個鍵，所以這使用三次按鍵（m, ,/<, .）而不是四個鍵。
- 按 `m` 允許玩家在向後方向重複最後使用的非基本移動（從 n,n 到 0,0）
- 按 `,` 允許玩家在最後使用的方向重複最後使用的非基本移動
- 按 `<` 允許玩家在最後使用的方向的相反方向重複最後使用的非基本移動
- 按 `.` 允許玩家在向前方向重複最後使用的非基本移動（從 0,0 到 n,n）

放棄原因：不確定的方向增加認知負擔

#### 172: 提案 2（採用）

或者，如下實現 `nm,.`：
- 按 `n` 允許玩家在向後方向重複最後使用的非基本移動（從 n,n 到 0,0）
- 按 `m` 允許玩家在向前方向重複最後使用的非基本移動（從 n,n 到 0,0）
  - 這實際上等同於在 VIM 中執行正常命令 `j0*`
  - 玩家應該向下移動一行並將列設置為零
  - 然後重複最後使用的非基本移動，類似於 VIM 中 `*` 的工作方式
  - 如果非基本移動失敗，則保持玩家在同一單元格
- 按 `,` 允許玩家在向後方向重複最後使用的非基本移動（從 0,0 到 n,n）
  - 這實際上等同於在 VIM 中執行正常命令 `k$#`
  - 玩家應該向上移動一行並將列設置為最後
  - 然後重複最後使用的非基本移動，類似於 VIM 中 `#` 的工作方式
  - 如果非基本移動失敗，則保持玩家在同一單元格
- 按 `.` 允許玩家在向前方向重複最後使用的非基本移動（從 0,0 到 n,n）

### 180: 擴展/縮小身體

這是一個非常特殊的功能，讓玩家擴展或縮小他們的身體長度（默認情況下，身體長度為 1）。
這預計會極大地改變遊戲玩法，玩家可能會在短時間內清除關卡。
因此，遊戲引擎應該格外小心地實現此功能。
請注意，增加玩家的身體長度會使遊戲玩法看起來非常類似於貪食蛇，除了：
1. 如果玩家的頭部與他們的身體碰撞，則沒有失敗條件
2. Vimkeys-game 將允許用戶切換玩家的活動部分：頭部、尾部或身體
  - 激活頭部或尾部時，意味著玩家處於可變長度模式
    - 當玩家移動到身體未佔用的單元格時，身體長度增加 1（上限為最大長度）
    - 當玩家移動到已被自己的身體佔用的單元格時，身體長度減少 1（下限為最小長度）
  - 激活身體模式時，意味著玩家處於固定長度模式
    - 玩家一次在視圖上移動整個身體，因此可能在單個移動動作中同時觸發多個碰撞事件

處理最大玩家長度的方法：
- 最小值：1；最大值：5
- 關卡可能會掉落隨機增益道具以增加最大長度的值

請注意，當身體長度大於 1 時，玩家將失去一些交互功能：
- 當身體長度 > 1 時，玩家無法觸發傳送門
  - 原因：為了保持遊戲平衡並防止使用延長身體過於容易地穿越
- 如果身體長度 > 1 且激活身體部分，則玩家無法使用符文移動
  - 即，如果玩家激活頭部或尾部部分，符文移動仍然有效
  - 原因 1：為頭部/尾部模式保持符文移動使遊戲更多樣化和有趣
  - 原因 2：符文移動需要特定的游標位置來計算目標；在激活身體部分時，沒有明顯的方法來確定哪個部分應該是活動游標

#### 181: 按鍵綁定提案 1（已放棄）

註冊兩次按鍵：`zx`
- `z` 在頭部或尾部之間切換（可變模式）
  - 如果玩家當前激活身體部分，則按 `z` 也會有效地激活切換
  - 例如，(cur)head => z => (cur)tail
  - 例如，(cur)tail => z => (cur)head
  - 例如，(cur)tail => x => (cur)body => z => (cur)head
- `x` 在可變或固定模式之間切換
  - 例如，(cur)head => x => (cur)body
  - 例如，(cur)tail => x => (cur)body => x => (cur)tail

優缺點：
- 優點：
  - 使用更少的按鍵
- 缺點：
  - 「切換」的認知負擔

應該在可變長度和固定長度模式之間有視覺差異。
應該為活動頭部/尾部部分引入視覺標記。
應該為先前活動的頭部/尾部部分引入視覺標記（如果當前激活身體部分）。

#### 182: 按鍵綁定提案 2（已放棄）

註冊三次按鍵：`zxc`
- `z` 切換到頭部部分（可變模式）
- `x` 切換到身體部分（固定模式）
- `c` 切換到尾部部分（可變模式）

優缺點：
- 優點：
  - 較少的「切換」認知負擔
- 缺點：
  - 需要更多按鍵
  - 如果玩家失去對頭部和尾部位置的追蹤，仍然有認知負擔

應該在可變長度和固定長度模式之間有視覺差異。
應該為頭部和尾部部分引入明顯的視覺差異。

#### 183: 按鍵綁定提案 3

註冊三次按鍵：`zxc`
- `z` 切換到尾部部分（可變模式）；觸發 `z` 也會觸發基本移動 `h`
- `x` 切換到身體部分（固定模式）
- `c` 切換到頭部部分（可變模式）；觸發 `c` 也會觸發基本移動 `l`

此版本旨在符合第一設計原則
因此，只有 'x' 動作會違反第一設計原則，這是為了更好的遊戲體驗而允許的

此外，此實現將頭部/尾部標記為網格單元格的結束/開始
即，最接近單元格 0,0 的身體部分被視為尾部；最接近單元格 n,n 的身體部分被視為頭部
這個改變將消除玩家可能潛在地交換頭部/尾部部分的問題

優缺點：
- 優點：
  - 較少的「切換」認知負擔
- 缺點：
  - 需要更多按鍵

### 已放棄的功能：搜索

**放棄原因：** 會減慢遊戲節奏並違反第一設計原則。

VIM 提供了非凡的搜索功能。然而，功能齊全的搜索功能會減慢遊戲節奏。此外，它違反了第一設計原則，其中搜索功能需要額外的回車鍵來激活。目前，items#142 中的查找字母命令已經足夠好了。

### 已放棄的功能：滾動

**放棄原因：** 不適用於固定視圖遊戲玩法。

VIM 用戶主要處理溢出當前視口的文件。然而，這不是 vimkeys-game 的情況。因此，只要遊戲不溢出網格，就不需要實現滾動功能。

## 200: 配置-遊戲玩法（拾取器模式）

拾取器（或拾取）模式是基本遊戲模式，遊戲在視圖上的隨機或固定位置掉落收集物。

**子模式 1（固定收集物，可變時間）：**
在遊戲開始時一次性渲染所有收集物。
一旦拾取所有收集物，遊戲就結束；分數由玩家結束遊戲的速度決定（花費的時間越少越好）。

**子模式 2（固定時間，可變收集物）：**
隨著遊戲進度動態渲染收集物（渲染數量上限為 max_display）。
一旦計時器結束，遊戲就結束；分數由玩家拾取了多少收集物決定。

### 實現提案 1

**核心規則：** `timer` 或 `remain_counter` 一次只能有一個為非空。它們是互斥的參數，決定遊戲模式。

數據：
- `int? timer` - 計時器（默認為 null，表示子模式 1）
  - 當設置為非空整數時，`remain_counter` 必須為 null
  - 設置為 10 將創建一個 10 秒計時器（表示子模式 2）
    - 一旦計時器歸零，遊戲結束
  - 隨著遊戲進度動態生成收集物
  - 新生成的位置將自動添加到 prev_positions
  - 使用 max_display 來確定一次顯示多少收集物
- `int? max_display` - 確定一次顯示的最大收集物數量（默認為 null）
  - 如果 remain_counter 為非空，則設置為 null
  - Null 值表示一次渲染所有剩餘的收集物
  - 如果 timer 為非空，則默認為 9
- `int? remain_counter` - 要生成的收集物數量（默認為 9）
  - 當設置為非空整數時，`timer` 必須為 null
  - 設置為 10 將創建一個 10 的 remain_counter
    - 一旦計數器歸零，遊戲結束
  - 如果 remain_counter 大於 positions.Count，遊戲應自動在隨機位置生成新的收集物，直到計數器歸零
    - 新生成的位置應添加回 prev_positions
- `List<(int, int)> prev_positions` - 先前的收集物位置（在關卡數據中定義）
- `bool` - 替換先前的位置，即，隨機生成（默認為 false）
  - 如果設置為 false，則重用先前的位置

### 210: 窗口拾取

遊戲默認一次顯示所有收集物。
此功能實現了一個配置，將最大顯示收集物限制為一個值（例如，一次最多 5 個）。

### 220: 基於速度

基於速度的結束遊戲條件意味著誰更早結束遊戲誰得分更好。
=> 換句話說，固定數量的收集物分數和可變計時器。

### 230: 基於分數

玩家在固定時間內嘗試獲得盡可能多的分數。

#### 231: 分數提升

此功能與基於分數的計分模式一起工作。
實現一些規則，允許玩家在滿足條件時獲得額外分數。
以下是一些可能的分數提升規則：
請注意，所有這些規則都應該是可配置的。

#### 232: 連擊連勝

連擊連勝狀態：如果玩家在 4 步內拾取收集物（即，在步驟 1、2、3 或 4 內），連勝刷新。

如果玩家連續 5 步或更多步而不拾取收集物，則玩家失去連擊連勝。

玩家在保持連勝的同時拾取收集物將獲得額外分數。

例如，如果超過 x2 連擊（即 x3+）則獲得一個額外分數；如果超過 x5 連擊（即 x6+）則獲得兩個額外分數；如果超過 x8 連擊（即 x9+）則獲得三個額外分數；最多上限三個額外分數。

#### 233: 遞減計數器

使每個新生成的收集物價值額外分數 5，然後每次玩家移動時減少額外分數。
此模式與 items#232 很好地協同，因為它們都讓玩家優先考慮最近的收集物。

#### 234: 有序收集物

使用序數序列標記所有收集物。

玩家在按正確順序拾取收集物時獲得額外分數。

此模式還維持連擊連勝；如果連勝中斷則失去額外分數。

額外分數算術增長（例如，+1、+2、+3...）。

#### 235: 到期

隨機掉落有時間限制的收集物。
這個類似於 items#233，除了如果計數器低於 1，收集物會自動消失。
確保它是可配置的。

### 236: 計分公式

本節定義所有計分機制的精確計算。

#### 基本分數

```
base_score = collectables_picked × 1
```

每拾取一個收集物會增加 1 基本分數。

#### 連擊乘數（items#232）

```
combo_bonus = floor(combo_streak / 3)
combo_bonus = min(combo_bonus, 3)  // 上限為 3

score_per_pickup = 1 + combo_bonus
```

| 連擊連勝         | 獎勵點數 | 每次拾取總計 |
| ---------------- | -------- | ------------ |
| 1-2（無連擊）    | +0       | 1            |
| 3-5（x3..5+1）   | +1       | 2            |
| 6-8（×6..8+2）   | +2       | 3            |
| 9+（×9..+3）     | +3       | 4            |

#### 遞減計數器（items#233）

```
counter_bonus = max(0, 5 - steps_since_spawn)
score_per_pickup = 1 + counter_bonus
```

每個收集物生成時都有 5 點獎勵，每次玩家移動減少 1。

#### 有序收集物（items#234）

```
order_bonus = consecutive_correct_pickups
score_per_pickup = 1 + order_bonus

// 中斷連勝時：
order_bonus = 0
```

獎勵算術增長：第 1 個正確 +1，第 2 個正確 +2，第 3 個 +3，等等。

#### 到期（items#235）

```
expiration_bonus = remaining_countdown
score_per_pickup = 1 + expiration_bonus

// 如果倒計時達到 0：
收集物消失，不授予分數
```

#### 最終分數計算（基於分數模式）

```
final_score = sum(score_per_pickup for each pickup)
```

#### 最終分數計算（基於速度模式）

```
純時間排名（無分數，只有時間）
```

### 240: 遊戲版本

遊戲為用戶提供設置以配置他們的按鍵綁定或遊戲玩法。

遊戲應該為用戶提供保存槽以存儲他們的設置。

請注意，保存槽應該分別管理按鍵綁定和遊戲玩法設置。

## 300: 配置-按鍵綁定

所有按鍵綁定都應該是可配置的。
按鍵綁定基本上是觸發移動的動作。
因此，它們應該在 items#100 部分中定義。

### 310: 默認按鍵綁定表

| 動作                        | 默認鍵      | 可重映射 | 類別         | 參考      |
| --------------------------- | ----------- | -------- | ------------ | --------- |
| 向左移動                    | `h`         | 是       | 基本移動     | items#120 |
| 向下移動                    | `j`         | 是       | 基本移動     | items#120 |
| 向上移動                    | `k`         | 是       | 基本移動     | items#120 |
| 向右移動                    | `l`         | 是       | 基本移動     | items#120 |
| 網格左                      | `Ctrl+h`    | 是       | 網格移動     | items#130 |
| 網格下                      | `Ctrl+j`    | 是       | 網格移動     | items#130 |
| 網格上                      | `Ctrl+k`    | 是       | 網格移動     | items#130 |
| 網格右                      | `Ctrl+l`    | 是       | 網格移動     | items#130 |
| 向後查找角括號 '<'          | `q`         | 是       | 符文移動     | items#141 |
| 向後查找角括號 '>'          | `w`         | 是       | 符文移動     | items#141 |
| 向前查找角括號 '<'          | `e`         | 是       | 符文移動     | items#141 |
| 向前查找角括號 '>'          | `r`         | 是       | 符文移動     | items#141 |
| 向後查找字母                | `d` + char  | 是       | 符文移動     | items#142 |
| 向前查找字母                | `f` + char  | 是       | 符文移動     | items#142 |
| 向後重複                    | `n`         | 是       | 重複器       | items#172 |
| 向前重複跳過同一行          | `m`         | 是       | 重複器       | items#172 |
| 向後重複跳過同一行          | `,`         | 是       | 重複器       | items#172 |
| 向前重複                    | `.`         | 是       | 重複器       | items#172 |
| 切換到尾部（+ 向左移動）    | `z`         | 是       | 身體控制     | items#183 |
| 切換到身體                  | `x`         | 是       | 身體控制     | items#183 |
| 切換到頭部（+ 向右移動）    | `c`         | 是       | 身體控制     | items#183 |

### 320: 按鍵綁定約束

1. **保留鍵（無法重新映射）**
   - `\` - 開始/停止遊戲（參見遊戲流程）
   - `=` - 切換到下一關卡
   - `<backspace>` - 切換到上一關卡
   - `]` - 隨機化關卡（僅限動態關卡）
   - `Escape` - 始終打開/關閉設置菜單
   - `Enter` - 確認菜單中的選擇

2. **衝突解決**
   - 如果用戶嘗試分配已在使用的鍵，則顯示警告
   - 提供交換綁定或取消更改
   - 宏不能使用已綁定到其他動作的鍵

3. **組合鍵**
   - 支持修飾鍵：`Ctrl`、`Shift`、`Alt`
   - 每個綁定最多一個修飾鍵
   - 允許 `Ctrl+字母` 組合
   - `Shift+字母` 產生大寫（視為不同的鍵）

### 330: 按鍵綁定存儲

按鍵綁定按保存槽存儲：

```json
{
  "slot_id": 1,
  "keybindings": {
    "move_left": "h",
    "move_down": "j",
    "move_up": "k",
    "move_right": "l",
    "grid_left": "ctrl+h",
    "find_alphabet": "f",
    "macros": {
      "macro_1": "hhhjjj",
      "macro_2": "llllk"
    }
  }
}
```

#### 設計筆記

只保存用戶定義的部分（即，如果與系統默認值相同，則無需存儲設置）

## 400: 視覺-背景

### 410: 地圖

當前遊戲玩法一次只渲染一個網格地圖。

玩家專門通過這些按鍵綁定在網格內移動：hjkl。

我想進一步擴展這個想法，一次渲染多個網格。

玩家可以選擇使用「hjkl」在不同網格之間移動，一旦他們觸及每個網格之間的邊界。

此外，遊戲應該引入新的按鍵綁定，讓玩家使用一次按鍵在每個網格之間傳送。

#### 示例

假設屏幕上有 9 個網格，採用 3×3 佈局：

玩家位於左上角的網格 (0,0)。

玩家按下 HJKL（大寫）將期望以下結果：
- H => 什麼都不會發生
- J => 移動到下方網格 (1,0)
- K => 什麼都不會發生
- L => 移動到右側網格 (0,1)

## 500: 視覺-前景

### 510: 戰爭迷霧

當前遊戲玩法完整顯示整個視圖。

此項目將實現一個功能，讓玩家只在一個小區域內發現收集物，這是玩家的視野範圍。

確保視野範圍的半徑是可配置的。

確保填充器和拾取器模式都正確實現戰爭迷霧。

#### 設計筆記

此配置最適合隨機生成的關卡（計時器 + 基於分數的模式）。
原因是在基於速度的模式中玩遊戲靜態關卡意味著遊戲應該消除遊戲玩法中的噪音，以便玩家可以輕鬆探索純速度。

### 520: 符文

我想在視圖中散布一些隨機的可打印 ASCII 字符。
首先，將這些可打印字符渲染到不同的單元格中。
然後，根據這些字符附加不同的功能。
目前不需要實現所有功能；我們將把這些功能留給下一階段。

可能的功能：
- **符文可消耗：**
  - 一旦玩家踏上就會被消耗
  - 被消耗的符文可能會根據某些規則重生或不重生
  - 被消耗的符文可能會給玩家額外的分數或超能力
- **符文不可消耗：**
  - 玩家可能有特殊移動來根據某些規則傳送到附近的符文
  - 一旦踏上就給用戶臨時力量或不給

### 530: 深度連結

我想將超連結的概念引入遊戲。
有兩個提案可用：

#### 設計筆記

最初，我試圖使連結與瀏覽器中錨點的工作方式相同。
因此，它需要玩家按某個鍵來觸發連結。
然而，這個設計與第一設計原則相矛盾，遊戲應盡可能消除非移動動作。
同樣，按鍵將玩家帶回上一個視圖，就像「返回」在瀏覽器中的工作方式一樣，也違反了第三設計原則。

#### 531: 類超連結（已放棄）

**放棄原因：** 違反第一設計原則（非移動動作）。

一個 HTML 錨點，玩家使用按鍵進入，然後傳送到視圖上的其他地方。要求玩家按鍵（例如，`t`）進入連結是一個非移動動作，會減慢快節奏的遊戲玩法。

#### 532: 類傳送門

一對在碰撞時傳送玩家的傳送門。
=> 這對傳送門可能位於同一視圖或不同視圖內。

### 540: 障礙物

玩家無法踏上包含障礙物的單元格。

遊戲引擎不應同時在同一單元格中渲染障礙物和任何其他物品。
- 如果單元格包含障礙物，則不能包含收集物、符文、傳送門或任何其他物品
- 這確保了清晰的碰撞行為並防止模糊的遊戲狀態

## 600: 視覺-HUD

有關分數、遊戲狀態和配置彈窗的信息。

### 610: 計分板

#### 611: 遊戲中顯示

在遊戲中時，HUD 顯示：

| 元素         | 位置                | 描述                                       |
| ------------ | ------------------- | ------------------------------------------ |
| 當前分數     | 左上角              | 運行分數總計                               |
| 連擊計數器   | 左上角（分數下方）  | 當前連擊乘數（如果啟用）                   |
| 計時器       | 右上角              | 經過時間或倒計時（取決於模式）             |
| 收集物計數   | 右上角（計時器下方）| 剩餘收集物（拾取器）或進度指示器（填充器） |
| 當前顏色     | 左下角              | 活動軌道顏色（僅限填充器模式）             |
| 停止提示     | 右下角              | "按 `\` 停止"                              |

#### 612: 遊戲外顯示

在遊戲外時：

| 元素               | 描述                                                    |
| ------------------ | ------------------------------------------------------- |
| 遊戲模式選擇器     | 在拾取器和填充器模式之間切換                             |
| 上一場遊戲分數     | 最近遊戲會話的分數                                       |
| 最高分數           | 有史以來達到的最高分數（每個關卡）                       |
| 關卡切換           | 當前關卡名稱以及導航提示（`=` / `<backspace>`）          |
| 配置訪問           | 打開設置彈窗的按鈕/連結                                  |
| 開始提示           | "按 `\` 開始"                                           |

### 620: 設置彈窗

#### 621: 彈窗結構

設置彈窗包含通過切換按鈕訪問的兩個主標籤：

```
┌─────────────────────────────────────────┐
│  [遊戲玩法] [按鍵綁定]                   │
├─────────────────────────────────────────┤
│                                         │
│  （標籤內容區域）                        │
│  保存槽：[1] [2] [3]                    │
├─────────────────────────────────────────┤
│  [應用] [重置為默認] [取消]              │
└─────────────────────────────────────────┘
```

#### 622: 遊戲玩法標籤內容

遊戲玩法標籤根據所選遊戲模式顯示不同的選項。拾取器模式和填充器模式各有自己的一組可配置設置。

**拾取器模式設置：**

| 設置           | 類型     | 選項                                          | 參考                 |
| -------------- | -------- | --------------------------------------------- | -------------------- |
| 遊戲模式       | 單選     | 拾取器 / 填充器                                | items#200, items#700 |
| 計分模式       | 單選     | 基於分數 / 基於速度                            | items#220, items#230 |
| 網格大小       | 下拉     | 小（8×8）/ 中（12×12）/ 大（16×16）            | items#810            |
| 收集物密度     | 滑塊     | 低 / 中 / 高                                   | items#820            |
| 身體長度模式   | 單選     | 可變 / 固定                                    | items#180, items#183 |
| 戰爭迷霧       | 開關     | 開 / 關                                        | items#510            |

**填充器模式設置：**

| 設置           | 類型     | 選項                                          | 參考                 |
| -------------- | -------- | --------------------------------------------- | -------------------- |
| 遊戲模式       | 單選     | 拾取器 / 填充器                                | items#200, items#700 |
| 網格大小       | 下拉     | 小（8×8）/ 中（12×12）/ 大（16×16）            | items#810            |

注意：填充器模式排除計分模式（始終基於速度）、身體長度模式（根據 items#700 禁用）和戰爭迷霧（不適用於靜態關卡）。

#### 623: 按鍵綁定標籤內容

以可編輯格式顯示 items#310 中的按鍵綁定表：
- 單擊鍵單元格以重新綁定
- 衝突的視覺指示器
- 每行的「重置」按鈕以恢復默認值

#### 624: 保存槽

- 用於存儲不同配置的三個保存槽
- 遊戲玩法設置和按鍵綁定保存到單獨的槽中
- 顯示當前活動槽的視覺指示器
- items#330 中定義的槽格式

## 700: 配置-遊戲玩法（填充器模式）

填充器（或填充）模式是從 vimkeys-game 的基本遊戲玩法擴展而來的特殊遊戲模式（從拾取器模式擴展）。

本文檔回顧了從基本遊戲玩法繼承的所有功能，然後明確包含或排除每個功能。

此外，它添加了填充器模式引入的新功能。

填充器模式是一種替代遊戲模式，具有以下功能：
- **不同渲染：**
  - 玩家現在留下軌道顏色
  - 拾取的收集物將改變單元格的背景顏色
- **額外拾取規則：**
  - 現在所有收集物都有預定義的條件；玩家必須滿足條件才能拾取收集物
  - 例如，收集物可能有條件「紅色」；那麼玩家必須先拾取「紅色」才能拾取紅色收集物
    - 顏色是特殊的收集物，不給予額外分數，它們會在幾步內重生（可配置）

填充器模式中的所有關卡都是預定義的；因此，沒有基於分數的遊戲玩法。唯一的結束遊戲條件是盡可能少的秒數內清除關卡（即，盡可能短的時間）。

### 排除

- 填充器模式應禁用 items#180
  - 原因是填充器模式引入了更多收集物交互
  - 允許玩家延長身體長度會使遊戲過於複雜
- 所有地圖都是靜態生成的；不支持隨機生成的地圖
  - 因此，不會有基於分數的遊戲玩法可用
  - 只有基於速度的遊戲玩法可用
- 無需實現 items#510
  - 原因是戰爭迷霧最適合隨機生成的地圖
  - 無需為基於速度的模式限制玩家

### 實現提案 1

數據：
- `int remain_counter` - 倒計時要拾取以贏得遊戲的收集物數量
- `List<Level> levels` - 定義關卡列表
  - 玩家可以選擇玩哪個關卡
  - 每個關卡都應該有自己的計分板
- 關卡屬性：
  - `string name` - 關卡名稱
  - `List<(int, int, Color)> colors` - 顏色重生位置及其附加的顏色
  - `List<(int, int, Color)> collectables` - 收集物生成位置及拾取的顏色條件

### 已放棄的功能：顯式填充命令

**放棄原因：** 違反第一設計原則（額外按鍵）。

最初試圖讓玩家按空格鍵來填充單元格。讓玩家顯式按空格鍵來填充單元格和按空格鍵來切換填充行為都違反了第一設計原則，因為它使玩家按額外的空格鍵來完成遊戲。閾值功能（需要取消不相關單元格的著色）在遊戲後也感覺很乏味。

### 已放棄的功能：筆觸寬度

**放棄原因：** 過度複雜化遊戲玩法。

一次填充多個單元格的功能；可以通過實現 items#180 來完成。然而，它會過度複雜化遊戲玩法。

### 已放棄的功能：筆觸深度

**放棄原因：** 不必要的複雜性。

當收集物在同一單元格中出現兩次時，製作不同級別的填充顏色的功能。然而，填充器模式在遊戲開始時渲染所有收集物；重生收集物會引入不必要的複雜性，而不會改善遊戲體驗。

### 最終設計

每個收集物現在都帶有要匹配的條件（例如，顏色）。
玩家可以拾取顏色物品來匹配條件。

顏色物品在玩家移動幾步後自動重生，這確保玩家總是可以通關。
拾取新的顏色物品會直接替換之前的顏色。

為訪問過的單元格著色仍然是一個可行的選擇；然而，它應該只提供視覺反饋而不改變遊戲玩法。

## 800: 關卡設計

本節定義如何構建、生成和存儲關卡。

### 810: 網格尺寸

默認網格尺寸：10x10

對於多網格視圖：
- 每個視圖的最大網格數：9（3×3 佈局）
- 網格邊距：網格之間 10px

### 820: 隨機關卡生成

對於具有隨機生成的拾取器模式：

#### 算法大綱
1. 創建指定尺寸的空網格
2. 放置玩家生成點
3. 放置障礙物（密度：單元格的 0-20%，可配置）
   - 確保障礙物不會阻擋所有路徑
4. 放置收集物
   - 確保所有收集物可以從生成點到達
5. 放置符文（可選，基於配置）
6. 放置傳送門（可選，成對）

#### 生成參數
| 參數              | 類型  | 默認值 | 描述                                        |
| ----------------- | ----- | ------ | ------------------------------------------- |
| obstacle_density  | float | 0.10   | 具有障礙物的單元格百分比（0.0 - 0.20）      |
| collectable_count | int   | 9      | 要放置的收集物數量                          |
| sigil_count       | int   | 0      | 要放置的符文數量                            |
| portal_pairs      | int   | 0      | 要放置的傳送門對數量                        |
| seed              | int?  | null   | 可重現性的隨機種子（null = 隨機）           |

### 830: 固定關卡格式

固定關卡以 JSON 存儲，具有以下結構：

```json
{
  "id": "level_001",
  "name": "教程 1",
  "mode": "picker",
  "grid": {
    "rows": 15,
    "cols": 15
  },
  "player_spawn": { "row": 5, "col": 7 },
  "items": [
    { "type": "collectable", "row": 2, "col": 3 },
    { "type": "collectable", "row": 8, "col": 12 },
    { "type": "obstacle", "row": 4, "col": 5 },
    { "type": "sigil", "subtype": "angle_left", "row": 3, "col": 10 },
    { "type": "portal", "pair_id": 1, "row": 1, "col": 1 },
    { "type": "portal", "pair_id": 1, "row": 9, "col": 14 }
  ],
  "filler_config": {
    "colors": [
      { "row": 0, "col": 0, "color": "red" }
    ],
    "collectables": [
      { "row": 5, "col": 5, "required_color": "red" }
    ]
  },
  "metadata": {
    "author": "designer_name",
    "difficulty": "easy",
    "par_time_seconds": 30
  }
}
```

### 840: 關卡驗證規則

在可以玩關卡之前，驗證：
1. 玩家生成位置在網格邊界內
2. 玩家生成位置不與障礙物或傳送門重疊
3. 所有收集物都可以從玩家生成點到達（尋路檢查）
4. 傳送門對是完整的（沒有孤立的傳送門）
5. 對於填充器模式：所有顏色源都可以到達
6. 網格尺寸在允許範圍內

---

## 附錄 A：技術要求

### 技術棧

- 獨立 HTML/CSS/JS
- 零框架和庫

### 瀏覽器兼容性

- 目標：現代常青瀏覽器（Chrome、Firefox、Safari、Edge）
- 最小視口：800×600
- MVP 不需要移動支持

### 性能目標

- 輸入延遲：< 16ms（60fps 時一幀）
- 幀率：最低 60fps
- 加載時間：寬帶上 < 2 秒
