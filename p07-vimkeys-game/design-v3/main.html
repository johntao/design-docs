<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIM Keys Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    #hud-top {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-height: 80px;
    }

    .hud-row {
      display: flex;
      gap: 20px;
      font-size: 16px;
    }

    .hud-label {
      color: #888;
    }

    .hud-value {
      color: #4ecdc4;
      font-weight: bold;
    }

    #level-display {
      font-size: 18px;
      color: #f7d794;
    }

    #start-hint {
      color: #888;
      font-size: 14px;
    }

    #grid-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .grid {
      display: grid;
      gap: 1px;
      background: #2d3436;
      padding: 2px;
      border: 2px solid #4a4a6a;
      border-radius: 4px;
    }

    .cell {
      width: 36px;
      height: 36px;
      background: #16213e;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      position: relative;
    }

    .cell-content {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    /* Item styles */
    .player {
      color: #00ff88;
      font-size: 24px;
      z-index: 10;
    }

    .player-body {
      color: #00cc66;
      font-size: 20px;
      z-index: 9;
    }

    .player-tail {
      color: #009944;
      font-size: 18px;
      z-index: 8;
    }

    .coin {
      color: #ffd700;
      font-size: 16px;
    }

    .volatile-coin {
      color: #ff6b6b;
      font-size: 18px;
    }

    .volatile-counter {
      position: absolute;
      top: 2px;
      right: 4px;
      font-size: 10px;
      color: #ff6b6b;
    }

    .obstacle {
      color: #636e72;
      font-size: 22px;
    }

    .portal {
      font-size: 20px;
    }

    .sigil {
      color: #a29bfe;
      font-size: 16px;
      font-weight: bold;
    }

    .detached-body {
      color: #ff9f43;
      opacity: 0.7;
    }

    #hud-bottom {
      display: flex;
      gap: 20px;
      font-size: 14px;
    }

    #settings-btn {
      background: none;
      border: 1px solid #4a4a6a;
      color: #888;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 4px;
      font-family: inherit;
    }

    #settings-btn:hover {
      background: #2d3436;
      color: #eee;
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: #1a1a2e;
      border: 2px solid #4a4a6a;
      border-radius: 8px;
      padding: 24px;
      min-width: 500px;
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 20px;
      color: #f7d794;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 24px;
      cursor: pointer;
    }

    .modal-close:hover {
      color: #eee;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .tab-btn {
      background: none;
      border: 1px solid #4a4a6a;
      color: #888;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 4px;
      font-family: inherit;
    }

    .tab-btn.active {
      background: #4a4a6a;
      color: #eee;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .config-section {
      margin-bottom: 20px;
    }

    .config-section-title {
      color: #4ecdc4;
      font-size: 14px;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .config-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #2d3436;
    }

    .config-label {
      color: #888;
    }

    .config-input {
      background: #16213e;
      border: 1px solid #4a4a6a;
      color: #eee;
      padding: 4px 8px;
      width: 80px;
      text-align: center;
      font-family: inherit;
    }

    .keybinding-row {
      display: grid;
      grid-template-columns: 1fr 80px 80px;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid #2d3436;
      align-items: center;
    }

    .keybinding-action {
      color: #888;
    }

    .keybinding-default {
      color: #4ecdc4;
      text-align: center;
    }

    .keybinding-custom {
      background: #16213e;
      border: 1px solid #4a4a6a;
      color: #eee;
      padding: 4px;
      text-align: center;
      font-family: inherit;
    }

    .keybinding-custom.conflict {
      border-color: #ff6b6b;
    }

    .save-slots {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }

    .slot-btn {
      background: #16213e;
      border: 1px solid #4a4a6a;
      color: #888;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 4px;
      font-family: inherit;
    }

    .slot-btn.active {
      background: #4a4a6a;
      color: #eee;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .modal-btn {
      background: none;
      border: 1px solid #4a4a6a;
      color: #888;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 4px;
      font-family: inherit;
    }

    .modal-btn:hover {
      background: #2d3436;
      color: #eee;
    }

    .modal-btn.primary {
      background: #4ecdc4;
      border-color: #4ecdc4;
      color: #1a1a2e;
    }

    .modal-btn.primary:hover {
      background: #3dbdb5;
    }

    /* Portal colors */
    .portal-1 { color: #ff6b6b; }
    .portal-2 { color: #4ecdc4; }
    .portal-3 { color: #f7d794; }
    .portal-4 { color: #a29bfe; }
    .portal-5 { color: #fd79a8; }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="hud-top">
      <!-- Dynamic content based on game state -->
    </div>

    <div id="grid-container">
      <!-- Grid will be rendered here -->
    </div>

    <div id="hud-bottom">
      <button id="settings-btn">Settings (Esc)</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settings-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="modal-title">Settings</span>
        <button class="modal-close">&times;</button>
      </div>

      <div class="tabs">
        <button class="tab-btn active" data-tab="gameplay">Gameplay</button>
        <button class="tab-btn" data-tab="keybindings">Keybindings</button>
      </div>

      <div id="tab-gameplay" class="tab-content active">
        <!-- Gameplay settings will be rendered here -->
      </div>

      <div id="tab-keybindings" class="tab-content">
        <!-- Keybinding settings will be rendered here -->
      </div>

      <div class="save-slots">
        <span class="config-label">Save Slot:</span>
        <button class="slot-btn active" data-slot="1">1</button>
        <button class="slot-btn" data-slot="2">2</button>
        <button class="slot-btn" data-slot="3">3</button>
        <button class="slot-btn" data-slot="4">4</button>
        <button class="slot-btn" data-slot="5">5</button>
      </div>

      <div class="modal-actions">
        <button class="modal-btn" id="reset-defaults-btn">Reset to Default</button>
        <button class="modal-btn" id="cancel-btn">Cancel</button>
        <button class="modal-btn primary" id="apply-btn">Apply</button>
      </div>
    </div>
  </div>

  <script src="level.js"></script>
  <script>
    // ============================================
    // GAME STATE
    // ============================================
    const GameState = {
      OUT_OF_GAME: 'out_of_game',
      IN_GAME: 'in_game'
    };

    // ============================================
    // DEFAULT CONFIGURATION
    // ============================================
    const DEFAULT_CONFIG = {
      gameplay: {
        countdownTimer: 30,
        lineOfSight: 0,
        sigilLetters: 'asdf',
        maxCoins: 10,
        coinSpawnFrequency: 4,
        volatileInitialCounter: 5,
        volatileDecrementalStep: 1,
        volatileSpawnFrequency: 8,
        maxBonusScore: 5,
        reattachScore: 1,
        obstacleDensity: 10,
        sigilDensity: 10,
        portalDensity: 10
      },
      keybindings: {
        moveLeft: 'h',
        moveDown: 'j',
        moveUp: 'k',
        moveRight: 'l',
        gridLeft: 'H',
        gridDown: 'J',
        gridUp: 'K',
        gridRight: 'L',
        sigil1Forward: 'a',
        sigil2Forward: 's',
        sigil3Forward: 'd',
        sigil4Forward: 'f',
        sigil1Backward: 'A',
        sigil2Backward: 'S',
        sigil3Backward: 'D',
        sigil4Backward: 'F'
      }
    };

    // ============================================
    // GAME ENGINE
    // ============================================
    const Game = {
      // State
      state: GameState.OUT_OF_GAME,
      currentLevelIndex: 0,
      currentLevel: null,
      config: JSON.parse(JSON.stringify(DEFAULT_CONFIG)),
      currentSlot: 1,

      // Player state
      player: {
        segments: [], // Array of {row, col} - head is [0], tail is last
        detachedSegments: [], // Array of arrays of {row, col}
        rigidMode: false,
        rigidCounter: 0
      },

      // Game data
      items: [], // Current items on grid
      score: 0,
      previousScore: 0,
      highScore: 0,
      timer: 0,
      timerInterval: null,
      actionCount: 0,

      // Dynamic level seed
      dynamicSeed: null,

      // ============================================
      // INITIALIZATION
      // ============================================
      init() {
        this.loadConfig();
        this.loadHighScores();
        this.loadLevel(this.currentLevelIndex);
        this.setupEventListeners();
        this.render();
      },

      loadConfig() {
        const saved = localStorage.getItem(`vimkeys_config_slot_${this.currentSlot}`);
        if (saved) {
          try {
            this.config = JSON.parse(saved);
          } catch (e) {
            this.config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
          }
        }
      },

      saveConfig() {
        localStorage.setItem(`vimkeys_config_slot_${this.currentSlot}`, JSON.stringify(this.config));
      },

      loadHighScores() {
        const saved = localStorage.getItem('vimkeys_highscores');
        if (saved) {
          try {
            this.highScores = JSON.parse(saved);
          } catch (e) {
            this.highScores = {};
          }
        } else {
          this.highScores = {};
        }
        this.highScore = this.highScores[this.currentLevelIndex] || 0;
      },

      saveHighScore() {
        if (this.score > this.highScore) {
          this.highScore = this.score;
          this.highScores[this.currentLevelIndex] = this.score;
          localStorage.setItem('vimkeys_highscores', JSON.stringify(this.highScores));
        }
      },

      // ============================================
      // LEVEL MANAGEMENT
      // ============================================
      loadLevel(index) {
        this.currentLevelIndex = index;
        this.currentLevel = getLevelByIndex(index);
        this.highScore = this.highScores[index] || 0;
        this.resetLevel();
      },

      resetLevel() {
        const level = this.currentLevel;

        // Reset player
        this.player.segments = [{ row: level.playerSpawn.row, col: level.playerSpawn.col }];
        this.player.detachedSegments = [];
        this.player.rigidMode = false;
        this.player.rigidCounter = 0;

        // Reset game data
        this.score = 0;
        this.actionCount = 0;
        this.timer = this.config.gameplay.countdownTimer;

        // Load items
        if (level.type === 'dynamic') {
          this.generateDynamicLevel();
        } else {
          this.items = JSON.parse(JSON.stringify(level.items || []));
        }

        this.render();
      },

      generateDynamicLevel() {
        if (!this.dynamicSeed) {
          this.dynamicSeed = Date.now();
        }

        const level = this.currentLevel;
        const rows = level.grid.rows;
        const cols = level.grid.cols;
        const totalCells = rows * cols;

        // Simple seeded random
        let seed = this.dynamicSeed;
        const random = () => {
          seed = (seed * 1103515245 + 12345) & 0x7fffffff;
          return seed / 0x7fffffff;
        };

        this.items = [];
        const occupied = new Set();

        // Mark player spawn as occupied
        const spawnRow = Math.floor(random() * rows);
        const spawnCol = Math.floor(random() * cols);
        this.currentLevel.playerSpawn = { row: spawnRow, col: spawnCol };
        occupied.add(`${spawnRow},${spawnCol}`);

        // Generate obstacles
        const obstacleCount = Math.floor(totalCells * this.config.gameplay.obstacleDensity / 100);
        for (let i = 0; i < obstacleCount; i++) {
          let row, col;
          do {
            row = Math.floor(random() * rows);
            col = Math.floor(random() * cols);
          } while (occupied.has(`${row},${col}`));
          occupied.add(`${row},${col}`);
          this.items.push({ type: 'obstacle', row, col });
        }

        // Generate portals (in pairs)
        const portalCount = Math.floor(totalCells * this.config.gameplay.portalDensity / 100 / 2) * 2;
        for (let i = 0; i < portalCount; i += 2) {
          const pairId = Math.floor(i / 2) + 1;
          for (let j = 0; j < 2; j++) {
            let row, col;
            do {
              row = Math.floor(random() * rows);
              col = Math.floor(random() * cols);
            } while (occupied.has(`${row},${col}`));
            occupied.add(`${row},${col}`);
            this.items.push({ type: 'portal', pairId, row, col });
          }
        }

        // Generate sigils
        const sigilLetters = this.config.gameplay.sigilLetters;
        const sigilCount = Math.floor(totalCells * this.config.gameplay.sigilDensity / 100);
        const sigisPerLetter = Math.max(4, Math.ceil(sigilCount / sigilLetters.length));

        for (let i = 0; i < sigilLetters.length; i++) {
          for (let j = 0; j < sigisPerLetter; j++) {
            let row, col;
            let attempts = 0;
            do {
              row = Math.floor(random() * rows);
              col = Math.floor(random() * cols);
              attempts++;
            } while (occupied.has(`${row},${col}`) && attempts < 100);

            if (attempts < 100) {
              // Sigils can overlap with other sigils but mark general area
              this.items.push({ type: 'sigil', letter: sigilLetters[i], row, col });
            }
          }
        }

        // Generate initial coins
        const initialCoins = Math.min(this.config.gameplay.maxCoins, 5);
        for (let i = 0; i < initialCoins; i++) {
          this.spawnCoin(random);
        }
      },

      spawnCoin(randomFn) {
        const level = this.currentLevel;
        const rows = level.grid.rows;
        const cols = level.grid.cols;

        const random = randomFn || Math.random;

        // Find occupied cells (by obstacles and portals only - coins can be on sigils)
        const blocked = new Set();
        this.items.forEach(item => {
          if (item.type === 'obstacle' || item.type === 'portal') {
            blocked.add(`${item.row},${item.col}`);
          }
        });

        // Also block player positions
        this.player.segments.forEach(seg => blocked.add(`${seg.row},${seg.col}`));

        // Block existing coins
        this.items.forEach(item => {
          if (item.type === 'coin' || item.type === 'volatileCoin') {
            blocked.add(`${item.row},${item.col}`);
          }
        });

        let row, col;
        let attempts = 0;
        do {
          row = Math.floor(random() * rows);
          col = Math.floor(random() * cols);
          attempts++;
        } while (blocked.has(`${row},${col}`) && attempts < 100);

        if (attempts < 100) {
          this.items.push({ type: 'coin', row, col });
        }
      },

      regenerateDynamicLevel() {
        if (this.currentLevel.type === 'dynamic') {
          this.dynamicSeed = Date.now();
          this.resetLevel();
        }
      },

      nextLevel() {
        const total = getLevelCount();
        this.loadLevel((this.currentLevelIndex + 1) % total);
      },

      previousLevel() {
        const total = getLevelCount();
        this.loadLevel((this.currentLevelIndex - 1 + total) % total);
      },

      // ============================================
      // GAME STATE MANAGEMENT
      // ============================================
      startGame() {
        if (this.currentLevel.type === 'demo') {
          // Demo levels just reset
          this.resetLevel();
          return;
        }

        if (this.state === GameState.OUT_OF_GAME) {
          this.state = GameState.IN_GAME;
          this.resetLevel();
          this.startTimer();
        } else {
          this.stopGame();
        }
        this.render();
      },

      stopGame() {
        this.state = GameState.OUT_OF_GAME;
        this.stopTimer();
        this.previousScore = this.score;
        this.saveHighScore();
        this.render();
      },

      startTimer() {
        this.stopTimer();
        this.timerInterval = setInterval(() => {
          this.timer--;
          if (this.timer <= 0) {
            this.stopGame();
          }
          this.renderHUD();
        }, 1000);
      },

      stopTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
      },

      // ============================================
      // MOVEMENT
      // ============================================
      move(direction) {
        const head = this.player.segments[0];
        let newRow = head.row;
        let newCol = head.col;

        switch (direction) {
          case 'left':  newCol--; break;
          case 'right': newCol++; break;
          case 'up':    newRow--; break;
          case 'down':  newRow++; break;
        }

        const level = this.currentLevel;

        // Boundary check
        if (newRow < 0 || newRow >= level.grid.rows ||
            newCol < 0 || newCol >= level.grid.cols) {
          return; // Stay at boundary
        }

        // Check for obstacle collision
        const obstacle = this.items.find(item =>
          item.type === 'obstacle' && item.row === newRow && item.col === newCol
        );
        if (obstacle) {
          return; // Blocked by obstacle
        }

        // Execute move
        this.executeMove(newRow, newCol, true);
      },

      executeMove(newRow, newCol, isCollidable) {
        const oldSegments = [...this.player.segments];

        if (this.player.rigidMode) {
          // Rigid mode: move entire body
          const deltaRow = newRow - this.player.segments[0].row;
          const deltaCol = newCol - this.player.segments[0].col;

          this.player.segments = this.player.segments.map(seg => ({
            row: seg.row + deltaRow,
            col: seg.col + deltaCol
          }));

          // Check collisions for all segments
          this.player.segments.forEach((seg, i) => {
            this.handleCollision(seg.row, seg.col, isCollidable);
          });

          // Decrement rigid counter
          this.player.rigidCounter--;
          if (this.player.rigidCounter <= 0) {
            this.player.rigidMode = false;
          }
        } else {
          // Normal mode: snake movement
          // Move head
          const newHead = { row: newRow, col: newCol };

          // Check for self-collision (attached body)
          const selfHit = this.player.segments.slice(1).findIndex(
            seg => seg.row === newRow && seg.col === newCol
          );

          if (selfHit !== -1) {
            // Attack: swap head and tail, reduce length
            this.handleAttack(selfHit + 1);
          } else {
            // Normal move
            this.player.segments.unshift(newHead);
            this.player.segments.pop();

            // Handle collision at new position
            this.handleCollision(newRow, newCol, isCollidable);
          }
        }

        this.actionCount++;

        // Spawn new coin periodically (only in-game and non-demo)
        if (this.state === GameState.IN_GAME &&
            this.actionCount % this.config.gameplay.coinSpawnFrequency === 0) {
          const coinCount = this.items.filter(i => i.type === 'coin').length;
          if (coinCount < this.config.gameplay.maxCoins) {
            this.spawnCoin();
          }
        }

        this.render();
      },

      handleCollision(row, col, isCollidable) {
        // Check for detached body parts
        for (let i = 0; i < this.player.detachedSegments.length; i++) {
          const detached = this.player.detachedSegments[i];
          const hitIndex = detached.findIndex(seg => seg.row === row && seg.col === col);

          if (hitIndex !== -1) {
            if (this.player.rigidMode) {
              // In rigid mode, just get score for the detached part length
              this.score += detached.length;
              this.player.detachedSegments.splice(i, 1);
            } else {
              // Normal mode: reattach
              this.handleAttach(i, hitIndex);
            }
            return;
          }
        }

        // Check for coins
        const coinIndex = this.items.findIndex(item =>
          (item.type === 'coin' || item.type === 'volatileCoin') &&
          item.row === row && item.col === col
        );

        if (coinIndex !== -1) {
          const coin = this.items[coinIndex];
          this.collectCoin(coin);
          this.items.splice(coinIndex, 1);
          return;
        }

        // Check for portals
        const portal = this.items.find(item =>
          item.type === 'portal' && item.row === row && item.col === col
        );

        if (portal) {
          this.handlePortal(portal);
          return;
        }
      },

      collectCoin(coin) {
        if (this.currentLevel.type === 'demo') {
          // Demo mode: just grow, no score
          this.growPlayer();
          return;
        }

        if (coin.type === 'volatileCoin') {
          this.score += 1 + (coin.counter || 0);
          this.player.rigidMode = true;
          this.player.rigidCounter = this.config.gameplay.volatileInitialCounter;
        } else {
          this.score += 1;
          if (!this.player.rigidMode) {
            this.growPlayer();
          }
        }
      },

      growPlayer() {
        // Add segment at tail position
        const tail = this.player.segments[this.player.segments.length - 1];
        this.player.segments.push({ ...tail });
      },

      handlePortal(portal) {
        // Find paired portal
        const pairedPortal = this.items.find(item =>
          item.type === 'portal' &&
          item.pairId === portal.pairId &&
          (item.row !== portal.row || item.col !== portal.col)
        );

        if (!pairedPortal) return;

        if (this.player.rigidMode) {
          // Rigid mode: split at portal
          // For now, just teleport the whole body
          const deltaRow = pairedPortal.row - this.player.segments[0].row;
          const deltaCol = pairedPortal.col - this.player.segments[0].col;
          this.player.segments = this.player.segments.map(seg => ({
            row: seg.row + deltaRow,
            col: seg.col + deltaCol
          }));
        } else {
          // Normal mode: detach head, teleport to paired portal
          if (this.player.segments.length > 1) {
            // Leave body behind as detached
            this.player.detachedSegments.push(this.player.segments.slice(1));
          }
          this.player.segments = [{ row: pairedPortal.row, col: pairedPortal.col }];
        }
      },

      handleAttach(detachedIndex, hitIndex) {
        const detached = this.player.detachedSegments[detachedIndex];

        // Get the tail of the detached segment
        const tail = detached[detached.length - 1];

        // Swap: head goes to tail position
        this.player.segments[0] = { ...tail };

        // Reattach the segments
        this.player.segments = [...this.player.segments, ...detached];

        // Remove from detached list
        this.player.detachedSegments.splice(detachedIndex, 1);

        // Score for reattaching
        if (this.currentLevel.type !== 'demo') {
          this.score += this.config.gameplay.reattachScore;
        }
      },

      handleAttack(hitIndex) {
        // Swap head and tail positions
        const tail = this.player.segments[this.player.segments.length - 1];
        this.player.segments[0] = { ...tail };

        // Reduce body length by 1
        this.player.segments.pop();
      },

      // Sigil movement
      moveSigil(letter, forward) {
        const sigils = this.items
          .filter(item => item.type === 'sigil' && item.letter === letter)
          .sort((a, b) => {
            // Sort by row then col
            if (a.row !== b.row) return a.row - b.row;
            return a.col - b.col;
          });

        if (sigils.length === 0) return;

        const head = this.player.segments[0];
        const currentPos = head.row * this.currentLevel.grid.cols + head.col;

        // Find sigils sorted by position
        const sigisWithPos = sigils.map(s => ({
          ...s,
          pos: s.row * this.currentLevel.grid.cols + s.col
        }));

        let targetSigil;

        if (forward) {
          // Find first sigil after current position (or wrap to first)
          targetSigil = sigisWithPos.find(s => s.pos > currentPos) || sigisWithPos[0];
        } else {
          // Find last sigil before current position (or wrap to last)
          const before = sigisWithPos.filter(s => s.pos < currentPos);
          targetSigil = before.length > 0 ? before[before.length - 1] : sigisWithPos[sigisWithPos.length - 1];
        }

        if (targetSigil) {
          // Sigil move is non-collidable, causes detachment
          if (this.player.segments.length > 1 && !this.player.rigidMode) {
            this.player.detachedSegments.push(this.player.segments.slice(1));
            this.player.segments = [{ row: targetSigil.row, col: targetSigil.col }];
          } else {
            this.executeMove(targetSigil.row, targetSigil.col, false);
          }
          this.actionCount++;
          this.render();
        }
      },

      // ============================================
      // RENDERING
      // ============================================
      render() {
        this.renderHUD();
        this.renderGrid();
      },

      renderHUD() {
        const hudTop = document.getElementById('hud-top');
        const level = this.currentLevel;

        if (this.state === GameState.IN_GAME) {
          hudTop.innerHTML = `
            <div class="hud-row">
              <span class="hud-label">Score:</span>
              <span class="hud-value">${this.score}</span>
            </div>
            <div class="hud-row">
              <span class="hud-label">Time:</span>
              <span class="hud-value">${this.timer}s</span>
            </div>
          `;
        } else {
          const isDemo = level.type === 'demo';
          hudTop.innerHTML = `
            <div class="hud-row">
              <span class="hud-label">Previous:</span>
              <span class="hud-value">${this.previousScore}</span>
              <span class="hud-label">High:</span>
              <span class="hud-value">${this.highScore}</span>
            </div>
            <div id="level-display">
              <span style="color:#888">[</span> ${level.name} <span style="color:#888">]</span>
            </div>
            <div id="start-hint">
              ${isDemo ? 'Press \\ to reset' : 'Press \\ to start'}
              ${level.type === 'dynamic' ? ' | Backspace to regenerate' : ''}
            </div>
          `;
        }
      },

      renderGrid() {
        const container = document.getElementById('grid-container');
        const level = this.currentLevel;
        const { rows, cols } = level.grid;

        let html = `<div class="grid" style="grid-template-columns: repeat(${cols}, 36px); grid-template-rows: repeat(${rows}, 36px);">`;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            html += `<div class="cell">${this.renderCell(r, c)}</div>`;
          }
        }

        html += '</div>';
        container.innerHTML = html;
      },

      renderCell(row, col) {
        let content = '';

        // Check for player segments
        const headIndex = this.player.segments.findIndex(seg => seg.row === row && seg.col === col);
        if (headIndex === 0) {
          content += `<span class="cell-content player">\u25a2</span>`;
        } else if (headIndex > 0) {
          if (headIndex === this.player.segments.length - 1 && this.player.segments.length > 1) {
            content += `<span class="cell-content player-tail">\u25a2</span>`;
          } else {
            content += `<span class="cell-content player-body">\u25a2</span>`;
          }
        }

        // Check for detached segments
        for (const detached of this.player.detachedSegments) {
          const detachedIndex = detached.findIndex(seg => seg.row === row && seg.col === col);
          if (detachedIndex !== -1) {
            content += `<span class="cell-content detached-body">\u25a2</span>`;
          }
        }

        // Check for items
        const items = this.items.filter(item => item.row === row && item.col === col);
        for (const item of items) {
          switch (item.type) {
            case 'coin':
              content += `<span class="cell-content coin">\u2022</span>`;
              break;
            case 'volatileCoin':
              content += `<span class="cell-content volatile-coin">\u22c6</span>`;
              content += `<span class="volatile-counter">${item.counter}</span>`;
              break;
            case 'obstacle':
              content += `<span class="cell-content obstacle">\u25ae</span>`;
              break;
            case 'portal':
              const portalClass = `portal-${((item.pairId - 1) % 5) + 1}`;
              content += `<span class="cell-content portal ${portalClass}">\u25cb</span>`;
              break;
            case 'sigil':
              content += `<span class="cell-content sigil">${item.letter}</span>`;
              break;
          }
        }

        return content;
      },

      // ============================================
      // SETTINGS MODAL
      // ============================================
      openSettings() {
        document.getElementById('settings-modal').classList.add('active');
        this.renderSettingsContent();
      },

      closeSettings() {
        document.getElementById('settings-modal').classList.remove('active');
      },

      renderSettingsContent() {
        // Render Gameplay tab
        const gameplayTab = document.getElementById('tab-gameplay');
        gameplayTab.innerHTML = `
          <div class="config-section">
            <div class="config-section-title">Gameplay</div>
            <div class="config-row">
              <span class="config-label">Countdown Timer (seconds)</span>
              <input type="number" class="config-input" id="cfg-countdownTimer" value="${this.config.gameplay.countdownTimer}">
            </div>
            <div class="config-row">
              <span class="config-label">Line of Sight (0 = unlimited)</span>
              <input type="number" class="config-input" id="cfg-lineOfSight" value="${this.config.gameplay.lineOfSight}">
            </div>
            <div class="config-row">
              <span class="config-label">Sigil Letters</span>
              <input type="text" class="config-input" id="cfg-sigilLetters" value="${this.config.gameplay.sigilLetters}" style="width:100px">
            </div>
          </div>

          <div class="config-section">
            <div class="config-section-title">Random Level Generation</div>
            <div class="config-row">
              <span class="config-label">Obstacle Density (%)</span>
              <input type="number" class="config-input" id="cfg-obstacleDensity" value="${this.config.gameplay.obstacleDensity}" min="0" max="20">
            </div>
            <div class="config-row">
              <span class="config-label">Sigil Density (%)</span>
              <input type="number" class="config-input" id="cfg-sigilDensity" value="${this.config.gameplay.sigilDensity}" min="0" max="20">
            </div>
            <div class="config-row">
              <span class="config-label">Portal Density (%)</span>
              <input type="number" class="config-input" id="cfg-portalDensity" value="${this.config.gameplay.portalDensity}" min="0" max="20">
            </div>
          </div>

          <div class="config-section">
            <div class="config-section-title">Coins</div>
            <div class="config-row">
              <span class="config-label">Max Displaying Coins</span>
              <input type="number" class="config-input" id="cfg-maxCoins" value="${this.config.gameplay.maxCoins}">
            </div>
            <div class="config-row">
              <span class="config-label">Spawn Frequency (actions)</span>
              <input type="number" class="config-input" id="cfg-coinSpawnFrequency" value="${this.config.gameplay.coinSpawnFrequency}">
            </div>
          </div>

          <div class="config-section">
            <div class="config-section-title">Volatile Coins</div>
            <div class="config-row">
              <span class="config-label">Initial Counter</span>
              <input type="number" class="config-input" id="cfg-volatileInitialCounter" value="${this.config.gameplay.volatileInitialCounter}">
            </div>
            <div class="config-row">
              <span class="config-label">Decremental Step</span>
              <input type="number" class="config-input" id="cfg-volatileDecrementalStep" value="${this.config.gameplay.volatileDecrementalStep}">
            </div>
            <div class="config-row">
              <span class="config-label">Spawn Frequency (actions)</span>
              <input type="number" class="config-input" id="cfg-volatileSpawnFrequency" value="${this.config.gameplay.volatileSpawnFrequency}">
            </div>
          </div>

          <div class="config-section">
            <div class="config-section-title">Scoring</div>
            <div class="config-row">
              <span class="config-label">Max Bonus Score</span>
              <input type="number" class="config-input" id="cfg-maxBonusScore" value="${this.config.gameplay.maxBonusScore}">
            </div>
            <div class="config-row">
              <span class="config-label">Reattach Score</span>
              <input type="number" class="config-input" id="cfg-reattachScore" value="${this.config.gameplay.reattachScore}">
            </div>
          </div>
        `;

        // Render Keybindings tab
        const keybindingsTab = document.getElementById('tab-keybindings');
        const kb = this.config.keybindings;
        const defaultKb = DEFAULT_CONFIG.keybindings;

        keybindingsTab.innerHTML = `
          <div class="config-section">
            <div class="config-section-title">Movement</div>
            <div class="keybinding-row">
              <span class="keybinding-action">Action</span>
              <span class="keybinding-default">Default</span>
              <span class="keybinding-default">Custom</span>
            </div>
            ${this.renderKeybindingRow('Move Left', 'moveLeft', defaultKb.moveLeft, kb.moveLeft)}
            ${this.renderKeybindingRow('Move Down', 'moveDown', defaultKb.moveDown, kb.moveDown)}
            ${this.renderKeybindingRow('Move Up', 'moveUp', defaultKb.moveUp, kb.moveUp)}
            ${this.renderKeybindingRow('Move Right', 'moveRight', defaultKb.moveRight, kb.moveRight)}
          </div>

          <div class="config-section">
            <div class="config-section-title">Grid Movement</div>
            ${this.renderKeybindingRow('Grid Left', 'gridLeft', defaultKb.gridLeft, kb.gridLeft)}
            ${this.renderKeybindingRow('Grid Down', 'gridDown', defaultKb.gridDown, kb.gridDown)}
            ${this.renderKeybindingRow('Grid Up', 'gridUp', defaultKb.gridUp, kb.gridUp)}
            ${this.renderKeybindingRow('Grid Right', 'gridRight', defaultKb.gridRight, kb.gridRight)}
          </div>

          <div class="config-section">
            <div class="config-section-title">Sigil Movement (Forward)</div>
            ${this.renderKeybindingRow('Sigil 1 Forward', 'sigil1Forward', defaultKb.sigil1Forward, kb.sigil1Forward)}
            ${this.renderKeybindingRow('Sigil 2 Forward', 'sigil2Forward', defaultKb.sigil2Forward, kb.sigil2Forward)}
            ${this.renderKeybindingRow('Sigil 3 Forward', 'sigil3Forward', defaultKb.sigil3Forward, kb.sigil3Forward)}
            ${this.renderKeybindingRow('Sigil 4 Forward', 'sigil4Forward', defaultKb.sigil4Forward, kb.sigil4Forward)}
          </div>

          <div class="config-section">
            <div class="config-section-title">Sigil Movement (Backward)</div>
            ${this.renderKeybindingRow('Sigil 1 Backward', 'sigil1Backward', defaultKb.sigil1Backward, kb.sigil1Backward)}
            ${this.renderKeybindingRow('Sigil 2 Backward', 'sigil2Backward', defaultKb.sigil2Backward, kb.sigil2Backward)}
            ${this.renderKeybindingRow('Sigil 3 Backward', 'sigil3Backward', defaultKb.sigil3Backward, kb.sigil3Backward)}
            ${this.renderKeybindingRow('Sigil 4 Backward', 'sigil4Backward', defaultKb.sigil4Backward, kb.sigil4Backward)}
          </div>
        `;
      },

      renderKeybindingRow(label, key, defaultVal, currentVal) {
        return `
          <div class="keybinding-row">
            <span class="keybinding-action">${label}</span>
            <span class="keybinding-default">${defaultVal}</span>
            <input type="text" class="keybinding-custom" id="kb-${key}" value="${currentVal || ''}" maxlength="1">
          </div>
        `;
      },

      applySettings() {
        // Read gameplay settings
        this.config.gameplay.countdownTimer = parseInt(document.getElementById('cfg-countdownTimer').value) || 30;
        this.config.gameplay.lineOfSight = parseInt(document.getElementById('cfg-lineOfSight').value) || 0;
        this.config.gameplay.sigilLetters = document.getElementById('cfg-sigilLetters').value || 'asdf';
        this.config.gameplay.obstacleDensity = parseInt(document.getElementById('cfg-obstacleDensity').value) || 10;
        this.config.gameplay.sigilDensity = parseInt(document.getElementById('cfg-sigilDensity').value) || 10;
        this.config.gameplay.portalDensity = parseInt(document.getElementById('cfg-portalDensity').value) || 10;
        this.config.gameplay.maxCoins = parseInt(document.getElementById('cfg-maxCoins').value) || 10;
        this.config.gameplay.coinSpawnFrequency = parseInt(document.getElementById('cfg-coinSpawnFrequency').value) || 4;
        this.config.gameplay.volatileInitialCounter = parseInt(document.getElementById('cfg-volatileInitialCounter').value) || 5;
        this.config.gameplay.volatileDecrementalStep = parseInt(document.getElementById('cfg-volatileDecrementalStep').value) || 1;
        this.config.gameplay.volatileSpawnFrequency = parseInt(document.getElementById('cfg-volatileSpawnFrequency').value) || 8;
        this.config.gameplay.maxBonusScore = parseInt(document.getElementById('cfg-maxBonusScore').value) || 5;
        this.config.gameplay.reattachScore = parseInt(document.getElementById('cfg-reattachScore').value) || 1;

        // Read keybindings
        const keybindingKeys = Object.keys(DEFAULT_CONFIG.keybindings);
        keybindingKeys.forEach(key => {
          const input = document.getElementById(`kb-${key}`);
          if (input) {
            this.config.keybindings[key] = input.value || DEFAULT_CONFIG.keybindings[key];
          }
        });

        this.saveConfig();
        this.closeSettings();
        this.render();
      },

      resetToDefaults() {
        this.config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
        this.renderSettingsContent();
      },

      selectSlot(slot) {
        this.currentSlot = slot;
        this.loadConfig();
        this.renderSettingsContent();

        // Update slot button UI
        document.querySelectorAll('.slot-btn').forEach(btn => {
          btn.classList.toggle('active', parseInt(btn.dataset.slot) === slot);
        });
      },

      // ============================================
      // EVENT HANDLERS
      // ============================================
      setupEventListeners() {
        // Keyboard input
        document.addEventListener('keydown', (e) => this.handleKeydown(e));

        // Settings modal
        document.getElementById('settings-btn').addEventListener('click', () => this.openSettings());
        document.querySelector('.modal-close').addEventListener('click', () => this.closeSettings());
        document.getElementById('apply-btn').addEventListener('click', () => this.applySettings());
        document.getElementById('cancel-btn').addEventListener('click', () => this.closeSettings());
        document.getElementById('reset-defaults-btn').addEventListener('click', () => this.resetToDefaults());

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const tab = e.target.dataset.tab;
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(`tab-${tab}`).classList.add('active');
          });
        });

        // Save slots
        document.querySelectorAll('.slot-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.selectSlot(parseInt(e.target.dataset.slot));
          });
        });
      },

      handleKeydown(e) {
        // Check if modal is open
        if (document.getElementById('settings-modal').classList.contains('active')) {
          if (e.key === 'Escape') {
            this.closeSettings();
          }
          return;
        }

        const key = e.key;
        const kb = this.config.keybindings;
        const sigilLetters = this.config.gameplay.sigilLetters;

        // Reserved keys
        switch (key) {
          case '\\':
            e.preventDefault();
            this.startGame();
            return;
          case 'Backspace':
            e.preventDefault();
            this.regenerateDynamicLevel();
            return;
          case '[':
            e.preventDefault();
            if (this.state === GameState.OUT_OF_GAME) {
              this.previousLevel();
            }
            return;
          case ']':
            e.preventDefault();
            if (this.state === GameState.OUT_OF_GAME) {
              this.nextLevel();
            }
            return;
          case 'Escape':
            e.preventDefault();
            this.openSettings();
            return;
        }

        // Only process movement if we can play
        if (this.state === GameState.OUT_OF_GAME && this.currentLevel.type !== 'demo') {
          return;
        }

        // Basic movement
        if (key === kb.moveLeft) {
          e.preventDefault();
          this.move('left');
        } else if (key === kb.moveDown) {
          e.preventDefault();
          this.move('down');
        } else if (key === kb.moveUp) {
          e.preventDefault();
          this.move('up');
        } else if (key === kb.moveRight) {
          e.preventDefault();
          this.move('right');
        }
        // Sigil movement forward
        else if (key === kb.sigil1Forward && sigilLetters.length >= 1) {
          e.preventDefault();
          this.moveSigil(sigilLetters[0], true);
        } else if (key === kb.sigil2Forward && sigilLetters.length >= 2) {
          e.preventDefault();
          this.moveSigil(sigilLetters[1], true);
        } else if (key === kb.sigil3Forward && sigilLetters.length >= 3) {
          e.preventDefault();
          this.moveSigil(sigilLetters[2], true);
        } else if (key === kb.sigil4Forward && sigilLetters.length >= 4) {
          e.preventDefault();
          this.moveSigil(sigilLetters[3], true);
        }
        // Sigil movement backward
        else if (key === kb.sigil1Backward && sigilLetters.length >= 1) {
          e.preventDefault();
          this.moveSigil(sigilLetters[0], false);
        } else if (key === kb.sigil2Backward && sigilLetters.length >= 2) {
          e.preventDefault();
          this.moveSigil(sigilLetters[1], false);
        } else if (key === kb.sigil3Backward && sigilLetters.length >= 3) {
          e.preventDefault();
          this.moveSigil(sigilLetters[2], false);
        } else if (key === kb.sigil4Backward && sigilLetters.length >= 4) {
          e.preventDefault();
          this.moveSigil(sigilLetters[3], false);
        }
      }
    };

    // ============================================
    // INITIALIZE GAME
    // ============================================
    document.addEventListener('DOMContentLoaded', () => {
      Game.init();
    });
  </script>
</body>
</html>
